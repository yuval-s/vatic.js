<!doctype html>

<html lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html; charseth=utf-8">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400,700,800|Montserrat+Alternates' rel='stylesheet'>
    <title>vatic.js - Video Annotation Tool</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        background-color: #F8F8F8;
        font-family: 'Open Sans', sans-serif, 'Arial';
        padding-bottom: 20px;
      }
	    
/*       .output { font-family: monospace; font-weight: bold; } */

      #doodle {
        position: relative;
        width: 0px;
        height: 0px;
        z-index: 2;
		  	margin: auto;
/* 		  	margin-top: 10px; */
      }

      #canvas {
        z-index: 1;
      }

      #titleBlock {
        background-color: #303840;
        height: 85px;
        padding-left: 20px;
        color: #A2A6A6;
				font-family: 'Montserrat Alternates', sans-serif;
        white-space: nowrap;
      }
	    
      ul {
        list-style-type: none;
        margin: 0;
        padding: 0;
      }
	    
      ul li {
        padding-left: 20px;
        padding-top: 10px;
      }
	    
	    p {
	    	margin: 0px;
	    	padding-top: 5px;
	    }
	    
      .bbox {
        border: 1px solid #FF0000;
        position: absolute;
        z-index: 3;
      }
      
			#button {
			  background-color: #2394F0;
			  border: none;
			  color: #ffffff;
			  padding: 10px;
			  text-align: center;
			  display: inline-block;
			  margin-top: 10px;
			  margin-bottom: 10px;
			  cursor: pointer;
			}

      .handle, .ui-resizable-handle {
        width: 11px;
        height: 11px;
        border-radius: 50%;
        border: 1px solid rgba(255, 0, 0, .5);
        background-color: rgba(255, 255, 0, .05);
        position: absolute;
      }

      .center-drag {
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        cursor: move;
      }

      .ui-resizable-n {
        left: 50%;
        transform: translate(-50%, -50%);
        cursor: n-resize;
      }

      .ui-resizable-s {
        left: 50%;
        bottom: 0%;
        transform: translate(-50%, 50%);
        cursor: s-resize;
      }

      .ui-resizable-w {
        top: 50%;
        transform: translate(-50%, -50%);
        cursor: w-resize;
      }

      .ui-resizable-e {
        right: 0%;
        top: 50%;
        transform: translate(50%, -50%);
        cursor: e-resize;
      }
			
			#sliderBlock {
				background-color: #000000;
				height: 20px;
        padding-top: 10px;
        padding-bottom: 5px;
		  	margin: auto;
		  	margin-bottom: 10px;
			}
			
			#play {
				background-color: rgba(0, 0, 0, 0);
				border: none;
				color: #aaaaaa;
				font-size: 20px;
				margin-top: -4px;
				margin-left: 5px;
  			cursor: pointer;
  			outline: none;
			}
			
			#speedLabel {
				padding-left:15px;
				color: #aaaaaa;
				font-size: 15px;
			}
			
			#speed {
				background-color: rgba(0, 0, 0, 0);
				border: none;
				padding-left:10px;
				margin-top: -2px;
				color: #aaaaaa;
				font-size: 15px;
  			outline: none;
			}
			
			#progress {
				background-color: #D9EAEF;
        border-radius: 5px;
				border: 1px solid #A5D5F0;
				color: #005D91;
				padding-left: 10px;
				padding-right: 10px;
		  	margin: auto;
		  	margin-top: 20px;
				width: 1000px;
				height: 40px;
			}
			
			#videoBlock {
				background-color: #E7E9E9; /* #303840; */
        border-radius: 5px;
/* 				border: 1px solid #000000; */
				padding: 10px;
		  	margin: auto;
		  	margin-top: 20px;
			}
			
			#block {
				background-color: #E7E9E9;
        border-radius: 5px;
/* 				border: 1px solid #D3D4D4; */
				color: #304060;
				padding: 10px;
		  	margin: auto;
		  	margin-top: 20px;
				width: 1000px;
			}
			
			#save {
				background-color: #E7E9E9;
        border-radius: 5px;
				color: #304060;
				padding: 10px;
		  	margin: auto;
		  	margin-top: 20px;
		  	width: 1000px;
			}
			
			#annotation {
				background-color: #F8F8F8; /* #eeeeee; */
        border-radius: 5px;
        border: 1px solid #DDDDDD;
				width: 145px;
				display: inline-block;
				margin: 15px;
				padding: 10px;
			}
			
			#code {
				background-color: #F8F8F8;
				font-family: 'Menlo';
				font-size: 14px;
				color: #005D91;
				padding-left: 10px;
				padding-right: 10px;
				padding-top: 3px;
				padding-bottom: 3px;
        border-radius: 5px;
			}
			
      .ui-slider {
        position: relative;
				background-color: #555555;
        text-align: left;
        height: 4px;
        margin-top: 6px;
        margin-left: 120px;
        border-radius: 5px;
      }

      .ui-slider-handle {
        position: absolute;
        background-color: #ff0000;
        z-index: 2;
        width: 8px;
        height: 8px;
        cursor: default;
        -ms-touch-action: none;
        touch-action: none;
        top: -3px;
        margin-left: -5px;
        border-radius: 5px;
  			outline: none;
      }

      .ui-widget.ui-widget-content {
      }

      .ui-state-default {
        border: 1px solid #aa0000;
      }

      .ui-state-hover, .ui-state-focus {
        border: 1px solid #cc0000;
        width: 10px;
        height: 10px;
        top: -4px;
        border-radius: 6px;
      }

      .ui-state-active {
      }

      .ui-state-disabled {
        opacity: .35;
      }

      .ui-corner-all {
      }
    </style>
  </head>
  <body>
    <a href="https://github.com/yuval-s/vatic.js" class="github-corner" aria-label="View source on Github"><svg width="85" height="85" viewBox="0 0 250 250" style="fill:#00aadd; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div id="titleBlock">
    	<p id="title"><a href="index.html" style="color: #ffffff; text-decoration: none; font-size: 30px;">vatic.js</a>
    	<span style="margin-left: 60px; font-size: 30px;">Video Annotation Tool</span>
			<a href="https://pjreddie.com/darknet/yolo/" target="_blank" style="color: #ffffff; text-decoration: none; font-size: 18px; margin-left: 5px;"><i>for YOLO!</i></a>
    	</p>
    	<p style="margin-top: 5px;">Optical flow is used to track your annotations, so that you have to do as little work as possible ;-)</p>
		</div>
		
   	<div id="videoBlock" hidden="true">
    	<div id="doodle">
      	<canvas id="canvas"></canvas>
      </div>
      <div id="sliderBlock">
      	<input type="button" id="play" value="►︎" style="float: left;" />
       	<label id="speedLabel" style="float: left;" >X</label>
       	<input type="text" id="speed" value="1.00" size="4" style="float: left;" />
       	<div id="slider"></div>
      </div>
    	<div id="objects" style="margin-left:10px; margin-right:10px;"></div>

    </div>
    <div id="save" hidden="true">
   		<p style="font-size: 20px; font-weight: bold; margin-bottom: 8px;">Save</p>
   		<p>After you finished annotating you can generate a <a href="https://pjreddie.com/darknet/" style="color: #0060C0;" target="_blank">YOLO</a> compatible annotations files.</p>
   		<p>Be sure to play the whole video from start to end to ensure no frame drops.</p>
   		<p>You can also download the extracted frames as <span id="code">.jpg</span></p>
	    <label id="button" style="margin-right: 20px; float: left;"><input type="button" id="generateXml" value="Generate" disabled="false" style="display: none"/>Generate annotations</label>
  	  <label id="button"><input type="button" id="downloadFrames" value="Download" disabled="disabled"  style="display: none;"/>Download frames</label>
  	</div>
  	  
		<div id="progress" hidden="true">
      <span class="output" id="extractionProgress" style=" padding-top: 10px; padding-left: 8px; float: left;"></span>
     	<span class="output" id="videoDimensions" style="padding-top: 10px; float: right;"></span>
   	</div>
   	
   	<div id="block">
   		<p style="font-size: 20px; font-weight: bold; margin-bottom: 8px;">Upload</p>
   		<p>You can either upload a video file or a zip archive of frame images.</p>
   		<p>If you're using zip archive, please make sure the names of the frames are as follows:
   		<span id="code">&ltzip name&gt_&ltframe number&gt.jpg</span></p>
      <label id="button" style="float: left; margin-right: 20px;"><input type="file" id="videoFile" accept=".mp4,.x-m4v,video/*" style="display: none;">Video file</label>
      <label id="button"><input type="file" id="zipFile" accept=".zip" style="display: none;">zip archive</label>
      <span style="margin-left: 20px;" id="upNew" hidden="true"><i>* Refresh the page after you finished, and before uploading a new file!</i></span>
      <br />Please keep the focus on the browser during the entire extraction process, or frames might be skipped.
    </div>
    
   	<div id="block">
   	 	<p style="font-size: 20px; font-weight: bold; margin-bottom: 8px;">Annotate</p>
    	<p>Press <span id="code">N</span> on your keyboard to create a new bounding box.</p>
			<p>You can also press either one of the number keys: <span id="code">0, 1, 2 ...</span> to auto-select the correct Class/ID.</p>
			<p><span id="code">Left-click</span> with you mouse on two locations in the video corresponding to the corners of the box.</p>
			<p>Use the <span id="code">spacebar</span> to play/pause the video, or the <span id="code">left</span> and <span id="code">right</span> arrows to navigate frame by frame.</p>
			<p>Classes are determined from the file <i>"classes.txt"</i>, but you can ignore the names and use your own ID values.</p>
		</div>
    

    <script type="text/javascript" src="dist/compatibility.js"></script>
    <script type="text/javascript" src="dist/jszip.js"></script>
    <script type="text/javascript" src="dist/StreamSaver.js"></script>
    <script type="text/javascript" src="dist/polyfill.js"></script>
    <script type="text/javascript" src="dist/jsfeat.js"></script>
    <script type="text/javascript" src="dist/nudged.js"></script>
    <script type="text/javascript" src="dist/pouchdb.min.js"></script>
    <script type="text/javascript" src="dist/jquery-1.12.4.js"></script>
    <script type="text/javascript" src="dist/jquery-ui.js"></script>
    <script type="text/javascript" src="vatic.js"></script>
    <script type="text/javascript" src="classes.txt"></script>
    <script type="text/javascript">
      "use strict";

      let config = {
        // Should be higher than real FPS to not skip real frames
        // Hardcoded due to JS limitations
        fps: 30,

        // Low rate decreases the chance of losing frames with poor browser performances
        playbackRate: 0.4,

        // Format of the extracted frames
        imageMimeType: 'image/jpeg',
        imageExtension: '.jpg',
      };
      
			let canvasMouseOver = false;
      let Video = document.getElementById('videoFile');
      let videoName;
      let zipName = document.getElementById('zipFile');
      let doodle = document.querySelector('#doodle');
      let canvas = document.querySelector('#canvas');
      let ctx = canvas.getContext('2d');
      let videoFile = document.querySelector('#videoFile');
      let zipFile = document.querySelector('#zipFile');
//       let xmlFile = document.querySelector('#xmlFile');
      let saveElement = document.querySelector('#save');
      let progressElement = document.querySelector('#progress');
      let videoBlockElement = document.querySelector('#videoBlock');
      let objectsElement = document.querySelector('#objects');
      let videoDimensionsElement = document.querySelector('#videoDimensions');
      let extractionProgressElement = document.querySelector('#extractionProgress');
      let downloadFramesButton = document.querySelector('#downloadFrames');
      let playButton = document.querySelector('#play');
      let speedInput = document.querySelector('#speed');
      let sliderElement = document.querySelector('#slider');
      let sliderBlockElement = document.querySelector('#sliderBlock');
      let generateXmlButton = document.querySelector('#generateXml');

      let framesManager = new FramesManager();
      let annotatedObjectsTracker = new AnnotatedObjectsTracker(framesManager);

      let slider = {
        init: function(min, max, onChange) {
          $(sliderElement).slider('option', 'min', min);
          $(sliderElement).slider('option', 'max', max);
          $(sliderElement).on('slidestop', (e, ui) => {
            onChange(ui.value);
          });
          $(sliderElement).slider('enable');
        },
        setPosition: function(frameNumber) {
          $(sliderElement).slider('option', 'value', frameNumber);
        },
        reset: function() {
          $(sliderElement).slider({disabled: true});
        }
      };
      slider.reset();

      let player = {
        currentFrame: 0,
        isPlaying: false,
        isReady: false,
        timeout: null,

        initialize: function() {
          this.currentFrame = 0;
          this.isPlaying = false;
          this.isReady = false;

          playButton.disabled = true;
        },

        ready: function() {
          this.isReady = true;

          playButton.disabled = false;
        },

        seek: function(frameNumber) {
          if (!this.isReady) {
            return;
          }

          this.pause();
          playButton.value = "►";

          if (frameNumber >= 0 && frameNumber < framesManager.frames.totalFrames()) {
            this.drawFrame(frameNumber);
            this.currentFrame = frameNumber;
          }
        },

        play: function() {
          if (!this.isReady) {
            return;
          }

          this.isPlaying = true;
          this.nextFrame();
        },

        pause: function() {
          if (!this.isReady) {
            return;
          }

          this.isPlaying = false;
          if (this.timeout != null) {
            clearTimeout(this.timeout);
            this.timeout = null;
          }
        },

        toogle: function() {
          if (!this.isPlaying) {
            this.play();
            if(!playButton.disabled){
            	playButton.value = "◼︎︎";
            }
          } else {
            this.pause();
            playButton.value = "►";
          }
        },

        nextFrame: function() {
          if (!this.isPlaying) {
            return;
          }

          if (this.currentFrame >= framesManager.frames.totalFrames()) {
            this.done();
            return;
          }

          this.drawFrame(this.currentFrame).then(() => {
            this.currentFrame++;
            this.timeout = setTimeout(() => this.nextFrame(), 1000 / (config.fps * parseFloat(speedInput.value)));
          });
        },

        drawFrame: function(frameNumber) {
          return new Promise((resolve, _) => {
            annotatedObjectsTracker.getFrameWithObjects(frameNumber).then((frameWithObjects) => {
              ctx.drawImage(frameWithObjects.img, 0, 0);

              for (let i = 0; i < frameWithObjects.objects.length; i++) {
                let object = frameWithObjects.objects[i];
                let annotatedObject = object.annotatedObject;
                let annotatedFrame = object.annotatedFrame;
                if (annotatedFrame.isVisible()) {
                  annotatedObject.dom.style.display = 'block';
                  annotatedObject.dom.style.width = annotatedFrame.bbox.width + 'px';
                  annotatedObject.dom.style.height = annotatedFrame.bbox.height + 'px';
                  annotatedObject.dom.style.left = annotatedFrame.bbox.x + 'px';
                  annotatedObject.dom.style.top = annotatedFrame.bbox.y + 'px';
                  annotatedObject.visible.prop('checked', true);
                } else {
                  annotatedObject.dom.style.display = 'none';
                  annotatedObject.visible.prop('checked', false);
                }
              }

              let shouldHideOthers = frameWithObjects.objects.some(o => o.annotatedObject.hideOthers);
              if (shouldHideOthers) {
                for (let i = 0; i < frameWithObjects.objects.length; i++) {
                  let object = frameWithObjects.objects[i];
                  let annotatedObject = object.annotatedObject;
                  if (!annotatedObject.hideOthers) {
                    annotatedObject.dom.style.display = 'none';
                  }
                }
              }

              slider.setPosition(this.currentFrame);

              resolve();
            });
          });
        },

        done: function() {
          this.currentFrame = 0;
          this.isPlaying = false;
          playButton.value = "►";
        }
      };

      function clearAllAnnotatedObjects() {
        for (let i = 0; i < annotatedObjectsTracker.annotatedObjects.length; i++) {
          clearAnnotatedObject(i);
        }
      }

      function clearAnnotatedObject(i) {
        let annotatedObject = annotatedObjectsTracker.annotatedObjects[i];
        annotatedObject.controls.remove();
        $(annotatedObject.dom).remove();
        annotatedObjectsTracker.annotatedObjects.splice(i, 1);
      }
				
			canvas.addEventListener("mouseover", canvasOver);
			canvas.addEventListener("mouseout", canvasOut);
      videoFile.addEventListener('change', extractionFileUploaded, false);
      zipFile.addEventListener('change', extractionFileUploaded, false);
      // xmlFile.addEventListener('change', importXml, false);
      playButton.addEventListener('click', playClicked, false);
      downloadFramesButton.addEventListener('click', downloadFrames, false);
      generateXmlButton.addEventListener('click', generateXml, false);

			function canvasOver() {
				canvasMouseOver = true;
			}
			
			function canvasOut() {
				canvasMouseOver = false;
			}

      function playClicked() {
				if (!player.isPlaying) {
          player.play();
          playButton.value = "◼︎︎";
        } else {
        	player.pause();
          playButton.value = "►";
        }
      }

      function downloadFrames() {
        let zip = new JSZip();

        let processed = 0;
        let totalFrames = framesManager.frames.totalFrames();
        for (let i = 0; i < totalFrames; i++) {
          framesManager.frames.getFrame(i).then((blob) => {
            zip.file(videoName + '_' + i + '.jpg', blob);

            processed++;
            if (processed == totalFrames) {
              let writeStream = streamSaver.createWriteStream(videoName + '_frames.zip').getWriter();
              zip.generateInternalStream({type: 'uint8array', streamFiles: true})
                 .on('data', data => writeStream.write(data))
                 .on('end', () => writeStream.close())
                 .resume();
            }
          });
        }
      }

      function initializeCanvasDimensions(img) {
        doodle.style.width = img.width + 'px';
        doodle.style.height = img.height + 'px';
//         document.getElementById('videoBlock').hidden = false;
//         videoBlockElement.hidden = false;
        videoBlockElement.style.width = (1000>img.width ? 1000 + 'px' : img.width + 'px');
//         canvas.hidden = false;
        canvas.width = img.width;
        canvas.height = img.height;
        sliderElement.style.width = img.width-135 + 'px';
        sliderBlockElement.style.width = img.width + 'px';
      }

      function extractionFileUploaded() {
        if (this.files.length != 1) {
          return;
        }
				
				videoBlockElement.hidden = true;
				saveElement.hidden = true;
        videoFile.disabled = true;
        zipFile.disabled = true;
        // xmlFile.disabled = true;
        downloadFramesButton.disabled = true;
        generateXmlButton.disabled = true;
        clearAllAnnotatedObjects();
        slider.reset();
        player.initialize();

        let promise;
        progressElement.hidden = false;
        if (this == videoFile) {
        	videoName = Video.files.item(0).name;
          let dimensionsInitialized = false;

          promise = extractFramesFromVideo(
            config,
            this.files[0],
            (percentage, framesSoFar, lastFrameBlob) => {
              blobToImage(lastFrameBlob).then((img) => {
                if (!dimensionsInitialized) {
                  dimensionsInitialized = true;
                  initializeCanvasDimensions(img);
                }
                ctx.drawImage(img, 0, 0);

                videoDimensionsElement.innerHTML = 'Video dimensions: ' + img.width + 'x' + img.height;
                extractionProgressElement.innerHTML = 'Processing: <b>' + videoName + '</b> - ' + (percentage * 100).toFixed(2) + '% completed, ' + framesSoFar + ' frames extracted';
              });
            });
        } else {
        	videoName = zipName.files.item(0).name;
//       		config.framesZipFilename = videoName.substring(0, videoName.length - 11);
					config.framesZipFilename = videoName.substring(0, videoName.length - 4);
//       		alert(config.framesZipFilename);
          promise = extractFramesFromZip(config, this.files[0]);
        }

        promise.then((frames) => {
        	if(this == videoFile){
          	extractionProgressElement.innerHTML = 'Processing: <b>' + videoName + '</b> - Extraction completed, ' + frames.totalFrames() + ' frames captured';
          } else{
          	extractionProgressElement.innerHTML = 'Processing: <b>' + videoName + '</b> - Extraction completed, ' + frames.totalFrames() + ' frames captured';
          }
          if (frames.totalFrames() > 0) {
            frames.getFrame(0).then((blob) => {
              blobToImage(blob).then((img) => {
                initializeCanvasDimensions(img);
                ctx.drawImage(img, 0, 0);
                videoDimensionsElement.innerHTML = 'Video dimensions: ' + img.width + 'x' + img.height;

                framesManager.set(frames);
                slider.init(
                  0,
                  framesManager.frames.totalFrames() - 1,
                  (frameNumber) => player.seek(frameNumber)
                );
                player.ready();

//                 xmlFile.disabled = false;
//                 playButton.disabled = false;
				        videoBlockElement.hidden = false;
				        saveElement.hidden = false;
								document.getElementById('upNew').hidden = false;
                downloadFramesButton.disabled = false;
                generateXmlButton.disabled = false;
              });
            });
          }

          videoFile.disabled = false;
          zipFile.disabled = false;
        });
      }

      function interactify(dom, onChange) {
        let bbox = $(dom);
        bbox.addClass('bbox');

        let createHandleDiv = (className) => {
          let handle = document.createElement('div');
          handle.className = className;
          bbox.append(handle);
          return handle;
        };

        bbox.resizable({
          containment: 'parent',
          handles: {
            n: createHandleDiv('ui-resizable-handle ui-resizable-n'),
            s: createHandleDiv('ui-resizable-handle ui-resizable-s'),
            e: createHandleDiv('ui-resizable-handle ui-resizable-e'),
            w: createHandleDiv('ui-resizable-handle ui-resizable-w')
          },
          stop: (e, ui) => {
            let position = bbox.position();
            onChange(Math.round(position.left), Math.round(position.top), Math.round(bbox.width()), Math.round(bbox.height()));
          }
        });

        bbox.draggable({
          containment: 'parent',
          handle: createHandleDiv('handle center-drag'),
          stop: (e, ui) => {
            let position = bbox.position();
            onChange(Math.round(position.left), Math.round(position.top), Math.round(bbox.width()), Math.round(bbox.height()));
          }
        });
      }

      let mouse = {
        x: 0,
        y: 0,
        startX: 0,
        startY: 0
      };

      let tmpAnnotatedObject = null;

      doodle.onmousemove = function (e) {
        let ev = e || window.event;
        if (ev.pageX) {
          mouse.x = ev.pageX;
          mouse.y = ev.pageY;
        } else if (ev.clientX) {
          mouse.x = ev.clientX;
          mouse.y = ev.clientY;
        }
        mouse.x -= doodle.offsetLeft;
        mouse.y -= doodle.offsetTop;

        if (tmpAnnotatedObject !== null) {
          tmpAnnotatedObject.width = Math.abs(mouse.x - mouse.startX);
          tmpAnnotatedObject.height = Math.abs(mouse.y - mouse.startY);
          tmpAnnotatedObject.x = (mouse.x - mouse.startX < 0) ? mouse.x : mouse.startX;
          tmpAnnotatedObject.y = (mouse.y - mouse.startY < 0) ? mouse.y : mouse.startY;

          tmpAnnotatedObject.dom.style.width = tmpAnnotatedObject.width + 'px';
          tmpAnnotatedObject.dom.style.height = tmpAnnotatedObject.height + 'px';
          tmpAnnotatedObject.dom.style.left = tmpAnnotatedObject.x + 'px';
          tmpAnnotatedObject.dom.style.top = tmpAnnotatedObject.y + 'px';
        }
      }

      doodle.onclick = function (e) {
        if (doodle.style.cursor != 'crosshair') {
          return;
        }

        if (tmpAnnotatedObject != null) {
          let annotatedObject = new AnnotatedObject();
          annotatedObject.dom = tmpAnnotatedObject.dom;
          let bbox = new BoundingBox(tmpAnnotatedObject.x, tmpAnnotatedObject.y, tmpAnnotatedObject.width, tmpAnnotatedObject.height);
          annotatedObject.add(new AnnotatedFrame(player.currentFrame, bbox, true));
          annotatedObjectsTracker.annotatedObjects.push(annotatedObject);
          tmpAnnotatedObject = null;

          interactify(
            annotatedObject.dom,
            (x, y, width, height) => {
              let bbox = new BoundingBox(x, y, width, height);
              annotatedObject.add(new AnnotatedFrame(player.currentFrame, bbox, true));
            }
          );

          addAnnotatedObjectControls(annotatedObject);

          doodle.style.cursor = 'default';
        } else {
          mouse.startX = mouse.x;
          mouse.startY = mouse.y;

          let dom = newBboxElement();
          dom.style.left = mouse.x + 'px';
          dom.style.top = mouse.y + 'px';
          tmpAnnotatedObject = { dom: dom };
        }
      }

      function newBboxElement() {
          let dom = document.createElement('div');
          dom.className = 'bbox';
          doodle.appendChild(dom);
          return dom;
      }

      function addAnnotatedObjectControls(annotatedObject) {
      	let divID = $('<div style="margin-bottom: 5px;">');
        let id = $('<input type="text" value="0" size="3" style="height: 20px; text-align: center;" />');
        annotatedObject.id = doodle.key;
        if (annotatedObject.id) {
          id.val(annotatedObject.id);
        }
        id.on('change keyup paste mouseup', function() {
          annotatedObject.id = this.value;
        });
				divID.append(id);
				
				let divClass = $('<div style="margin-bottom: 5px; margin-right: 5px; float: left;">');
        let classLabel = $('<select style="height: 26px; width: 100px; font-size: 14px; background-color: #ffffff;"></select>')
        for(let i = 0; i<classes.length; i++){
        	let option;
        	if(i == doodle.key){
        		option = $('<option selected></option>');
        	} else{
        		option = $('<option></option>');
        	}
        	option.val(i);
        	option.append(classes[i]);
        	classLabel.append(option);
        }
        if (annotatedObject.name) {
          classLabel.val(annotatedObject.name);
        }
        classLabel.change(function() {
          id.val(this.value);
          annotatedObject.id = this.value;
        });
        classLabel.on('change keyup paste mouseup', function() {
          annotatedObject.name = this.value;
        });
				divClass.append(classLabel);
				
				let divVisible = $('<div style="margin-bottom: 5px;">');
        let visibleLabel = $('<label>');
        let visible = $('<input type="checkbox" checked="checked" style="margin-right:7px;"/>');
        annotatedObject.visible = visible;
        visible.change(function() {
          let bbox;
          if (this.checked) {
            annotatedObject.dom.style.display = 'block';
            let jquery = $(annotatedObject.dom);
            let position = jquery.position();
            bbox = new BoundingBox(Math.round(position.left), Math.round(position.top), Math.round(jquery.width()), Math.round(jquery.height()));
          } else {
            annotatedObject.dom.style.display = 'none';
            bbox = null;
          }
          annotatedObject.add(new AnnotatedFrame(player.currentFrame, bbox, true));
        });
        visibleLabel.append(visible);
        visibleLabel.append('Visible');
        divVisible.append(visibleLabel);

				let divHide = $('<div style="margin-bottom: 5px;">');
        let hideLabel = $('<label>');
        let hide = $('<input type="checkbox" style="margin-right:7px;"/>');
        hide.change(function() {
          annotatedObject.hideOthers = this.checked;
        });
        hideLabel.append(hide);
        hideLabel.append('Hide others');
				divHide.append(hideLabel);
				
				let divDel = $('<div>');
				let delLabel = $('<label id="button" style="background-color: #E7003B;">');
        let del = $('<input type="button" value="Delete" style="display: none;"/>');
        del.click(function() {
          for (let i = 0; annotatedObjectsTracker.annotatedObjects.length; i++) {
            if (annotatedObject === annotatedObjectsTracker.annotatedObjects[i]) {
              clearAnnotatedObject(i);
              break;
            }
          }
        });
        delLabel.append(del)
        delLabel.append('Delete');
				divDel.append(delLabel);
				
        let div = $('<div id="annotation"></div>');
        div.append(divClass);
        div.append(divID);
        div.append(divVisible);
        div.append(divHide);
        div.append(divDel);

        annotatedObject.controls = div;

        $('#objects').append(div);
      }

      function generateXml() {
      	let zip = new JSZip();
				let processed = 0;
        let totalFrames = framesManager.frames.totalFrames();
        
        for (let frameNumber = 0; frameNumber < totalFrames; frameNumber++){ // for every frame
        	let xml = '';
        	
          for (let i = 0; i < annotatedObjectsTracker.annotatedObjects.length; i++){ // for every bounding box
          	let annotatedObject = annotatedObjectsTracker.annotatedObjects[i];
            let annotatedFrame = annotatedObject.get(frameNumber);
            if (annotatedFrame == null) {
              window.alert('Play the video in full before downloading the XML so that bounding box data is available for all frames.');
              return;
            }
            let bbox = annotatedFrame.bbox;
            if (bbox != null) {
         	  	xml += annotatedObject.id + ' ';
              xml += (Math.round(bbox.x + bbox.width/2)/canvas.width) + ' ';
              xml += (Math.round(bbox.y + bbox.height/2)/canvas.height) + ' ';
              xml += (bbox.width/canvas.width) + ' ';
              xml += (bbox.height/canvas.height);
            }
            if((i < annotatedObjectsTracker.annotatedObjects.length-1) && (bbox != null)){
            	xml += '\n';
            }
          }
          
		  		zip.file(videoName + '_' + frameNumber + '.txt', xml);
        	processed++;
    	  	if (processed == totalFrames){
        		let writeStream = streamSaver.createWriteStream(videoName + '_annotations.zip').getWriter();
          	zip.generateInternalStream({type: 'uint8array', streamFiles: true})
          		 .on('data', data => writeStream.write(data))
          		 .on('end', () => writeStream.close())
          		 .resume();
          }
        }
      }

      function importXml() {
        if (this.files.length != 1) {
          return;
        }

        var reader = new FileReader();
        reader.onload = (e) => {
          if (e.target.readyState != 2) {
            return;
          }

          if (e.target.error) {
            throw 'file reader error';
          }

          let xml = $($.parseXML(e.target.result));
          let objects = xml.find('object');
          for (let i = 0; i < objects.length; i++) {
            let object = $(objects[i]);
            let name = object.find('name').text();
            let id = object.find('id').text();

            let annotatedObject = new AnnotatedObject();
            annotatedObject.name = name;
            annotatedObject.id = id;
            annotatedObject.dom = newBboxElement();
            annotatedObjectsTracker.annotatedObjects.push(annotatedObject);

            interactify(
              annotatedObject.dom,
              (x, y, width, height) => {
                let bbox = new BoundingBox(x, y, width, height);
                annotatedObject.add(new AnnotatedFrame(player.currentFrame, bbox, true));
              }
            );

            addAnnotatedObjectControls(annotatedObject);

            let lastFrame = -1;
            let polygons = object.find('polygon');
            for (let j = 0; j < polygons.length; j++) {
              let polygon = $(polygons[j]);
              let frameNumber = parseInt(polygon.find('t').text());
              let pts = polygon.find('pt');
              let topLeft = $(pts[0]);
              let bottomRight = $(pts[2]);
              let isGroundThrough = parseInt(topLeft.find('l').text()) == 1;
              let x = parseInt(topLeft.find('x').text());
              let y = parseInt(topLeft.find('y').text());
              let w = parseInt(bottomRight.find('x').text()) - x;
              let h = parseInt(bottomRight.find('y').text()) - y;

              if (lastFrame + 1 != frameNumber) {
                let annotatedFrame = new AnnotatedFrame(lastFrame + 1, null, true);
                annotatedObject.add(annotatedFrame);
              }

              let bbox = new BoundingBox(x, y, w, h);
              let annotatedFrame = new AnnotatedFrame(frameNumber, bbox, isGroundThrough);
              annotatedObject.add(annotatedFrame);

              lastFrame = frameNumber;
            }

            if (lastFrame + 1 < framesManager.frames.totalFrames()) {
              let annotatedFrame = new AnnotatedFrame(lastFrame + 1, null, true);
              annotatedObject.add(annotatedFrame);
            }
          }

          player.drawFrame(player.currentFrame);
        };
        reader.readAsText(this.files[0]);
      }

      // Keyboard shortcuts
      window.onkeydown = function(e) {
				
        let preventDefault = true;


        if (e.keyCode === 32) { // space
          player.toogle();
        } else if (e.keyCode === 78 && canvasMouseOver) { // n
          doodle.style.cursor = 'crosshair';
          doodle.key = 0;
        } else if ((e.keyCode === 48 || e.keyCode === 96) && classes.length > 0 && canvasMouseOver) { // 0
          doodle.style.cursor = 'crosshair';
          doodle.key = 0;
        } else if ((e.keyCode === 49 || e.keyCode === 97) && classes.length > 1 && canvasMouseOver) { // 1
          doodle.style.cursor = 'crosshair';
          doodle.key = 1;
        } else if ((e.keyCode === 50 || e.keyCode === 98) && classes.length > 2 && canvasMouseOver) { // 2
          doodle.style.cursor = 'crosshair';
          doodle.key = 2;
        } else if ((e.keyCode === 51 || e.keyCode === 99) && classes.length > 3 && canvasMouseOver) { // 3
          doodle.style.cursor = 'crosshair';
          doodle.key = 3;
        } else if ((e.keyCode === 52 || e.keyCode === 100) && classes.length > 4 && canvasMouseOver) { // 4
          doodle.style.cursor = 'crosshair';
          doodle.key = 4;
        } else if ((e.keyCode === 53 || e.keyCode === 101) && classes.length > 5 && canvasMouseOver) { // 5
          doodle.style.cursor = 'crosshair';
          doodle.key = 5;
        } else if ((e.keyCode === 54 || e.keyCode === 102) && classes.length > 6 && canvasMouseOver) { // 6
          doodle.style.cursor = 'crosshair';
          doodle.key = 6;
        } else if ((e.keyCode === 55 || e.keyCode === 103) && classes.length > 7 && canvasMouseOver) { // 7
          doodle.style.cursor = 'crosshair';
          doodle.key = 7;
        } else if ((e.keyCode === 56 || e.keyCode === 104) && classes.length > 8 && canvasMouseOver) { // 8
          doodle.style.cursor = 'crosshair';
          doodle.key = 8;
        } else if ((e.keyCode === 57 || e.keyCode === 105) && classes.length > 9 && canvasMouseOver) { // 9
          doodle.style.cursor = 'crosshair';
          doodle.key = 9;
        } else if (e.keyCode === 27) { // escape
          if (tmpAnnotatedObject != null) {
            doodle.removeChild(tmpAnnotatedObject.dom);
            tmpAnnotatedObject = null;
          }
          doodle.style.cursor = 'default';
        } else if (e.keyCode == 37) { // left
          player.seek(player.currentFrame - 1);
        } else if (e.keyCode == 39) { // right
          player.seek(player.currentFrame + 1);
        } else {
          preventDefault = false;
        }

        if (preventDefault) {
          e.preventDefault();
        }
      };
    </script>
  </body>
</html>
